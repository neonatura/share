/*
** $Id: luac.c,v 1.69 2011/11/29 17:46:33 lhf Exp $
** Lua compiler (saves bytecodes to files; also list bytecodes)
** See Copyright Notice in lua.h
*/

#include <share.h>

#include "sexe.h"
#include "lauxlib.h"
#include "ltable.h"
#include "lstate.h"
#include "lundump.h"


#define PROGNAME	"sexec"		/* default program name */
#define OUTPUT		PROGNAME ".sexe"	/* default output file */

static const char* process_name=PROGNAME;	/* actual program name */
static char out_path[PATH_MAX+1];
static char app_name[4096];


static void fatal(const char* message)
{
 fprintf(stderr,"%s: %s\n",process_name,message);
 exit(EXIT_FAILURE);
}

static void cannot(const char* what)
{
 fprintf(stderr,"%s: cannot %s %s: %s\n",process_name,what,out_path,strerror(errno));
 exit(EXIT_FAILURE);
}


#define IS(s)	(strcmp(argv[i],s)==0)


#define FUNCTION "(function()end)();"

static const char* reader(lua_State *L, void *ud, size_t *size)
{
 UNUSED(L);
 if ((*(int*)ud)--)
 {
  *size=sizeof(FUNCTION)-1;
  return FUNCTION;
 }
 else
 {
  *size=0;
  return NULL;
 }
}

#define toproto(L,i) getproto(L->top+(i))

static const Proto* combine(lua_State* L, int n, char *progname)
{
	char sexe_progname[MAX_SEXE_NAME_LENGTH];
	Proto* f;
	int i=n;

	if (n==1) {
		return toproto(L,-1);
	}

	if (!progname) progname = PROGNAME;
	memset(sexe_progname, 0, sizeof(sexe_progname));
	snprintf(sexe_progname, sizeof(sexe_progname)-1, "=(%s)", progname); 

  if (sexe_load(L,reader,&i,sexe_progname,NULL)!=LUA_OK) fatal(lua_tostring(L,-1));
  f=toproto(L,-1);
  for (i=0; i<n; i++)
  {
   f->p[i]=toproto(L,i-n-1);
   if (f->p[i]->sizeupvalues>0) f->p[i]->upvalues[0].instack=0;
  }
  f->sizelineinfo=0;
  return f;
}

static int writer(lua_State* L, const void* p, size_t size, void* u)
{
 UNUSED(L);
 return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
}


static int pmain(lua_State* L)
{
  int argc=(int)lua_tointeger(L,1);
  char** argv=(char**)lua_touserdata(L,2);
  const Proto* f;
	char progname[MAX_SEXE_NAME_LENGTH];
	char *text;
	uint32_t crc;
  int tot;
  int i;


  if (!lua_checkstack(L,argc)) fatal("too many input files");

  tot = 0;
	crc = 0;
  for (i=1; i<argc; i++) {
    if (argv[i][0] == '-') continue;
    if (0 == strcmp(argv[i], out_path)) continue;
    if (sexe_loadfile(L,argv[i], NULL)!=LUA_OK) fatal(lua_tostring(L,-1));
    tot++;

		text = basename(argv[i]);
		crc += shcrc32(text, strlen(text));
  }

	memset(progname, 0, sizeof(progname));
	snprintf(progname, sizeof(progname)-1, "%u", crc);
  f=combine(L, tot, progname);

  if (!(run_flags & RUNF_TEST)) {
    FILE* D = fopen(out_path, "wb");
    if (D==NULL) cannot("open");
    lua_lock(L);
    sexe_bin_write(L,f,writer,D, (run_flags & RUNF_STRIP));
    lua_unlock(L);
    if (ferror(D)) cannot("write");
    if (fclose(D)) cannot("close");
    chmod(out_path, 0777);
  }

  return 0;
}

void print_process_usage(void)
{
  char *app_name = shfs_app_name(process_name);

  printf (
      "Usage: %s [OPTION] [<files>]\n"
      "The libshare SEXE bytecode compiler.\n"
      "\n"
      "Options:\n"
      "\t-h | --help\t\tShows program usage instructions.\n"
      "\t-v | --version\t\tShows program version.\n"
      "\t-V | --verbose\t\tShow verbose information.\n"
      "\t-o <file>\t\tThe generated SEXE bytecode file.\n"
      "\t-g \t\t\tInclude debug information in generated bytecode.\n"
      "\t-t | --test\t\tTest integrity of source files.\n"
      "\t-f | --fs <name>\tUse application \"<name>\"'s sharefs partition.\n"
      "\n"
      "Files:\n"
      "\tOne or more files which contain Lua source code or pre-compiled SEXE bytecode.\n"
      "\n"
      "Visit 'http://sharelib.net/libshare/' for libshare API documentation.\n",
      app_name);
}

void print_process_version(char *process_path)
{
  char *app_name = shfs_app_name(process_path);
  printf (
      "%s version %-2.2f\n"
      "\n"
      "Copyright 2014 Neo Natura\n"
      "Licensed under the GNU GENERAL PUBLIC LICENSE Version 3\n",
      app_name, SEXE_VERSION);
}


int main(int argc, char* argv[])
{
  lua_State* L;
  int i;

  process_name = argv[0];

  run_flags |= RUNF_STRIP;
  run_flags |= RUNF_LOCAL;
  memset(app_name, 0, sizeof(app_name));
  for (i = 1; i < argc; i++) {
    if (IS("-v") || IS("--version")) {
      print_process_version(argv[0]);
      return (EXIT_SUCCESS);
    }
    if (IS("-h") || IS("--help")) {
      print_process_usage();
      return (EXIT_SUCCESS);
    }
    if (IS("-t") || IS("--test")) {
      run_flags |= RUNF_TEST;
      continue;
    }
    if (IS("-g")) {
      run_flags &= ~RUNF_STRIP;
      continue;
    }
    if (IS("-V") || IS("--verbose")) {
      run_flags |= RUNF_VERBOSE;
      continue;
    }
    if (IS("-l") || IS("--local")) {
      run_flags &= ~RUNF_LOCAL;
      if (i + 1 < argc && argv[i+1][0] != '-') {
        i++;
        strncpy(app_name, argv[i], sizeof(app_name) - 1);
      }
      continue;
    }
    if (IS("-o")) {
      i++;
      if (i >= argc)
        break;
      run_flags |= RUNF_OUTPUT;
      memset(out_path, 0, sizeof(out_path));
      strncpy(out_path, argv[i], PATH_MAX);
      continue;
    }
    if (argv[i][0] == '-') {
      printf("Warning: Invalid command-line option \"%s\".\n", argv[i]);
      continue;
    }

    /* source file specification. */
    run_flags |= RUNF_INPUT;
  }

  if (!(run_flags & RUNF_INPUT)) {
    printf("Error: no input file(s) specified.\n");
    exit(1);
  }

  if (!(run_flags & RUNF_TEST) && !(run_flags & RUNF_OUTPUT)) {
    printf("Error: no output file specified.\n");
    exit(1);
  }

  L=luaL_newstate();
  if (L==NULL) fatal("cannot create state: not enough memory");
  lua_pushcfunction(L,&pmain);
  lua_pushinteger(L,argc);
  lua_pushlightuserdata(L,argv);
  if (lua_pcall(L,2,0,0)!=LUA_OK) fatal(lua_tostring(L,-1));
  lua_close(L);

  return (EXIT_SUCCESS);
}



